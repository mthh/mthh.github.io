Exercice 3 : Géométries et calcul de champ
==========================================


.. figure:: img/ex3_intro.png
  :width: 30%
  :align: center
  :figwidth: 98%

Objectif
--------

L'objectif de cet exercice est double : manipuler les géométries relatives à chaque
entités et éditer une couche pour l'enrichir.

À partir de la couche vectorielle contenant les pays du monde, nous cherchons
à trouver tous les polygones limitrophes à chaque polygone *(tous les voisins de chaque pays)*.

La couche d'entrée va être enrichie de deux nouveaux champs, l'un contenant
le noms des voisins et l'autre contenant la population totale de ces voisins.


Données
-------

Les données proviennent de Natural Earth [#f1]_.

| -> ``TP/data/ne_10m_admin_0_countries`` (Polygones - Pays du monde)

Procédure
---------

La méthode à utiliser peut être décrite de la manière suivante :

    Pour chaque pays **P**:

      - trouver les polygones qui intersectent sa bounding box
      - parmis ces polygones :

        * trouver ceux qui sont réelement voisins du pays **P**
      - enregistrer le nom des voisins de **P** dans le champ ``NEIGHBORS``
      - enregistrer la somme de la population de ces voisins dans le champ ``SUM``

Cet exerice mobilise plusieurs notions nouvelles :

    - édition d'une couche

    ::

      # Au début de l'édition :
      layer.startEditing()

      # À la fin de l'édition :
      layer.commitChanges()


    - création de nouveaux champs attributaires

    ::

      # La couche `layer` doit être en cours d'édition !
      # Création d'un champ de type "Chaine de caractère" et d'un champ "entier"
      layer.dataProvider().addAttributes(
              [QgsField("Champ_1", QVariant.String),
               QgsField("Champ_2", QVariant.Int)])
      layer.updateFields()

    - utilisation de prédicats spatiaux (intersects, disjoint, etc.)

    ::

      # Obtenir la géométrie d'une entité :
      geom1 = feature1.geometry()
      geom2 = feature2.geometry()

      # Prédicats spatiaux :
      geom1.intersects(geom2) # -> True/False
      geom1.disjoint(geom2) # -> True/False
      geom1.touches(geom2) # -> True/False

    - utilisation d'un `index spatial`_

    ::

      # Création de l'index :
      index = QgsSpatialIndex()
      for f in layer.getFeatures()
          index.insertFeature(f)

      # Interrogation de l'index
      # (l'argument de la méthode intersects de l'index
      #  spatial doit être de type `QgsRectangle`)
      intersecting_ids = index.intersects(geom.boundingBox())


| **À vous de jouer !**
| **Essayer d'écrire le script permettant d'atteindre l'objectif de cet exercice**
| **Ouvrir ensuite le script déjà écrit et prendre le temps de bien le comprendre avant de l'exécuter si vous n'êtes pas arrivé à l'ensemble du résultat attendu lors de cet exercice.**

.. container:: spoiler blq

   Solution :

   ::

      from qgis.utils import iface
      from PyQt5.QtCore import QVariant

      # Nom des champs à utiliser :
      _NAME_FIELD = 'NAME'
      _SUM_FIELD = 'POP_EST'

      # Nom des champs à créer
      _NEW_NEIGHBORS_FIELD = 'NEIGHBORS'
      _NEW_SUM_FIELD = 'SUM'

      layer = iface.activeLayer()

      # Création des deux nouveaux champs après avoir activé le mode édition
      layer.startEditing()
      layer.dataProvider().addAttributes(
              [QgsField(_NEW_NEIGHBORS_FIELD, QVariant.String),
               QgsField(_NEW_SUM_FIELD, QVariant.Int)])
      layer.updateFields()

      # Creation d'un dictionnaire contenant nos entités
      # (cela va permettre d'avoir un mappage rapide entre un id et l'entité
      # correspondante, et également de parcourir plusieurs fois la liste
      # des entités sans appeler à nouveau la méthode `getFeatures`
      feature_dict = {f.id(): f for f in layer.getFeatures()}

      # Construction d'un index spatial :
      index = QgsSpatialIndex()
      for f in feature_dict.values():
          index.insertFeature(f)

      # Parcours de l'ensemble de nos entités :
      for f in feature_dict.values():
          # print('Calcul en cours pour {}'.format(f[_NAME_FIELD]))
          geom = f.geometry()
          # Recherche des entités qui intersectent la bbox de l'entité courrante
          # L'utilisation d'un index spatial permet à ce moment de n'itérer que
          # sur les entités qui intersectent sa bbox et non pas sur l'ensemble
          # des entités.
          intersecting_ids = index.intersects(geom.boundingBox())

          # Pour stocker la liste des voisins :
          neighbors = []
          neighbors_sum = 0

          for intersecting_id in intersecting_ids:
              # Look up the feature from the dictionary
              intersecting_f = feature_dict[intersecting_id]

              # Ici on considère qu'un entité est voisine si elle touche ou intersecte
              # l'entité en cours. Nous utilisons donc le prédicat spatial
              # 'disjoint' pour vérifier cela:
              if (f != intersecting_f and
                  not intersecting_f.geometry().disjoint(geom)):
                  neighbors.append(intersecting_f[_NAME_FIELD])
                  neighbors_sum += intersecting_f[_SUM_FIELD]

          f[_NEW_NEIGHBORS_FIELD] = ','.join(neighbors)
          f[_NEW_SUM_FIELD] = neighbors_sum
          # Mise à jour de l'entité modifiée :
          layer.updateFeature(f)

      layer.commitChanges()



.. rubric:: Footnotes

.. [#f1] http://www.naturalearthdata.com/. Données téléchargées le 28/02/2019.

.. _`index spatial`: https://fr.wikipedia.org/wiki/Index_spatial
