Exercice 5 : Ouverture d'un raster et enrichissement d'une couche vecteur
=========================================================================

.. figure:: img/ex5_mnt_color.png
  :width: 40%
  :align: center
  :figwidth: 98%


Objectif
--------

L'objectif de cet exerice est de créer le profil longitudinal d'un cours d'eau.

Cette opération nécessite de disposer de points à distance régulière le long du cours d'eau.
Une valeur d'altitude va ensuite être récupéréee à partir d'un modèle numérique de terrain.

.. figure:: img/ex5_matplotlib.png
  :width: 40%
  :align: center
  :figwidth: 98%


Données
-------

| -> ``TP/data/ex5/Canal_Furon.shp`` (Ligne - Source : IGN [#f1]_)
| -> ``TP/data/ex5/DEM_N245E395_l93.tif`` (Raster float 32bits - Source : EAA [#f2]_)

Les deux jeux de données utilisent la projection Lambert-93 (EPSG:2154).

Procédure
---------

- Ouvrir QGIS 3.

- Créer un nouveau projet.

- Ajouter les couches ``Canal_Furon.shp`` et ``DEM_N245E395_l93.tif`` puis ouvrir la console Python.

- Obtenir la référence de chacune de nos couches :

  ::

    line_lyr = QgsProject.instance().mapLayersByName("Canal_Furon")[0]
    dem = QgsProject.instance().mapLayersByName("DEM_N245E395_l93")[0]

- Disposer des points à égale distance le long du tracé du cours d'eau

  ::

    # Quelle est la longueur du cours d'eau ?
    ft = list(line_lyr.getFeatures())[0]
    geom = ft.geometry()
    length = geom.length() # En unités de la carte (ici en m.)

    # Combien de points ?
    nb_pts = 50

    # Distance entre points successifs
    step = length / nb_pts

    # Création d'un itérateur approprié et ajout des points créés à une liste :
    result = []
    for dist in range(0, int(length), int(step)):
        # Le resultat va être de type `QgsGeometry`
        interp = geom.interpolate(dist)
        # Convertit la géométrie en `QgsPoint` et l'ajoute au résultat
        result.append(interp.asPoint())

- Récupérer la valeur de la bande unique de notre couche raster à un point donné

  ::

    data_pr = dem.dataProvider()

    # L'argument doit être de type `QgsPoint`
    pt = QgsPoint(12673.233, 1332.344)
    alt, valid = data_pr.sample(pt, 1)
    if valid:
        print('Altitude : {}m'.format(alt))


- **"Putting it all together"**

  Vous disposez des briques essentielles pour créer un objet python de type ``list``,
  contenant, pour chaque point, sa distance à la source et son altitude sous la forme,
  par exemple, d'un ``tuple`` de 2 éléments (les coordonnées précises de chaque
  point ne nous intéressaient que pour connaitre son altitude).
  Ces deux informations, distance à la source et altitude, seront utilisées,
  respectivement en abcisses et en ordonnées, pour tracer le profil du cours d'eau.

  ::

    import matplotlib.pyplot as plt

    # Nos 2 couches de référence à utiliser
    line_lyr = QgsProject.instance().mapLayersByName("Canal_Furon")[0]
    dem = QgsProject.instance().mapLayersByName("DEM_N245E395_l93")[0]

    # Récupération de la géométrie du cours d'eau
    ft = list(line_lyr.getFeatures())[0]
    geom = ft.geometry()
    length = geom.length()

    # Nombre de points / distance entre chaque point
    nb_pts = 50
    step = length / nb_pts

    # Le fournisseur de données de la couche raster
    dem_pr = dem.dataProvider()

    # La liste qui va acceuillir les résultats
    result = []

    # Construction du résultat
    for dist in range(0, int(length), int(step)):
        interp = geom.interpolate(dist) # Le resultat est de type `QgsGeometry`
        alt, valid = data_pr.sample(interp.asPoint(), 1)
        if valid:
            result.append((dist, alt))

    # Affichage avec matplotlib
    plt.plot([i[0] for i in result], [i[1] for i in result])
    plt.xlabel('Distance à la source')
    plt.ylabel('Altitude')
    plt.show()


- **Variante : utiliser ces points pour créer une couche de point 3D**
  Contrairement à l'exemple précédent, les coordonnées de chaque nouveau point
  nous intéressent; elles vont être enrichie de l'altitude du point.
  Ces points vont être ajoutés à une nouvelle couche en mémoire qui aura
  précédemment été créée avec deux champs attributaires,
  l'un pour l'identifiant du point (de type *entier*) et l'autre pour
  la distance à la source (de type *double flottant*).

  ::

    line_lyr = QgsProject.instance().mapLayersByName("Canal_Furon")[0]
    dem = QgsProject.instance().mapLayersByName("DEM_N245E395_l93")[0]

    # Récupération de la géométrie du cours d'eau
    ft = list(line_lyr.getFeatures())[0]
    geom = ft.geometry()
    length = geom.length()

    # Nombre de points / distance entre chaque point
    nb_pts = 50
    step = length / nb_pts

    # Le fournisseur de données de la couche raster
    dem_pr = dem.dataProvider()

    # Nouvelle couche (en mémoire) de points et son fournisseur de données
    layer = QgsVectorLayer('Point?crs=EPSG:2154', 'PointsWithAltitude' , 'memory')
    pr = layer.dataProvider()

    # Spécification de deux champs
    # (un entier pour l'ID et un entier pour la distance à la source)
    pr.addAttributes([
        QgsField("ID",  QVariant.Int),
        QgsField("dist_source", QVariant.Double),
    ])
    layer.updateFields()

    for ix, dist in enumerate(range(0, int(length), int(step))):
        pt = geom.interpolate(dist).asPoint()
        alt, valid = data_pr.sample(pt, 1)
        if valid:
            new_pt = QgsPoint(pt)
            new_pt.setZ(alt)
        feat = QgsFeature()
        feat.setGeometry(QgsGeometry(new_pt))
        feat.setAttributes([ix, dist])
        ok = pr.addFeature(feat)
        if not ok:
          # Peut se produire si le nombre ou le type d'attribut ne correspondent
          # à ceux attendus pour cette couche
          print("Erreur lors de la création de l'entité {}".format(ix))

    # Mise à jour de l'étendue de la couche
    layer.updateExtents()

    # Ajout de la couche
    QgsProject.instance().addMapLayer(layer)


.. note::
  L'API exposée par PyQgis n'est pas toujours très "pythonique".
  Certaines fonctions vues au cours de cet exercice ne vont pas générer une ``exception``
  comme c'est la convention en Python mais vont retourner une valeur booléenne qu'il
  faudra lire pour s'assurer de la bonne exécution de la fonction en question.

  .. code-block:: python
     :emphasize-lines: 3,4,10,11

      for ix, dist in enumerate(range(0, int(length), int(step))):
          pt = geom.interpolate(dist).asPoint()
          alt, valid = data_pr.sample(pt, 1)
          if valid:
              new_pt = QgsPoint(pt)
              new_pt.setZ(alt)
          feat = QgsFeature()
          feat.setGeometry(QgsGeometry(new_pt))
          feat.setAttributes([ix, dist])
          ok = pr.addFeature(feat)
          if not ok:
            print("Erreur lors de la création de l'entité {}".format(ix))


.. rubric:: Footnotes

.. [#f1] Institut national de l'information géographique et forestière : http://professionnels.ign.fr/bdtopo. Données téléchargées le 28/02/2019.
.. [#f2] European Environment Agency : https://www.eea.europa.eu/data-and-maps/data/copernicus-land-monitoring-service-eu-dem. Données téléchargées le 28/02/2019.
